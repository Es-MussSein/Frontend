<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dom.html</title>

</head>
<body>
    <!-- 4.3 cloneNode-->
    <!-- <div id="parent">
        我是父元素的文本
        <br/>
        <span>我是子元素</span>
    </div>
    <button id="btnCopy">复制以上文本</button> -->

    <!-- 4.4 createDocumentFragment -->
    <!-- <ul id="ul"></ul> -->

    <!-- 5.1 appendChild -->
    <!-- <br>
    <div id="child">要被添加的节点</div><br><br><br><br>
    <div id="parent">要移动的位置</div>
    <input type="button" id="btnMove" value="移动节点"> -->

    <!-- 5.2 insertBefore -->
    <!-- <div id="parent">父节点
        <div id="child">
           子元素
        </div>
    </div>
    <input type="button" id="btnInsert" value="插入节点"> -->

    <!-- 5.3 removeChild -->
    <!-- <div id="parent">父元素
        <div id="child">子元素</div>
    </div>
    <input type="button" id="btnRemoveChild" value="删除子节点"> -->

    <!-- 5.4 replaceChild -->
    <!-- <div id="parent">父节点
        <div id="child">
            子元素
        </div>
    </div>
    <input type="button" id="btnReplaceChild" value="替换节点"> -->

    <!-- 6.1 document.getElementById -->
    <!-- <p id="para1">Some text here.</p>
    <button onclick="changeColor('green')">green</button>
    <button onclick="changeColor('skyblue')">skyblue</button> -->

    <!-- 6.2 document.getElementsByTagName -->
    <!-- <div>div1</div>
    <div>div2</div>
    <input type="button" id="btnShowCount" value="显示div数量">
    <input type="button" id="btnAddDiv" value="新增div"> -->

    <!-- 6.3 document.getElementsByName -->
    <!-- <input type="text" name="myInput" size="20" ><br>
    <input type="text" name="myInput" size="20" ><br>
    <input type="text" name="myInput" size="20" ><br><br>
    <input type="button" onclick="getElements()" value="How many elements named 'myInput?"> -->

    <!-- 6.4 document.getElementsByClassName -->

    <!-- 6.5.1 document.querySelector -->
    <!-- <div>
        <div>
            <span class="test">第三级的span</span>
        </div>
    </div>
    <div class="test">同级的第二个div</div>
    <input type="button" id="btnGet" value="获取test元素"> -->

    <!-- 6.5.2 document.querySelectorAll -->
    <!-- <div class="test">class is test</div>
    <div class="test">id is test</div>
    <div class="test">id is test</div>
    <div class="test">id is test</div>
    <input type="button" id="btnShow" value="显示内容"> -->

    <!-- 8.1 setAttribute -->
    <!-- <div id="div1">ABC</div> -->

    <!-- 8.2 getAttribute -->
    <!-- <div id="div2">abc</div> -->

    <!-- 8.3 removeAttribute()  -->
    <!-- <div id="div3" style="color:brown" width="200px">hola!</div>
    <input type="button" name="" id="btnRemoveAttribute" value="删除属性"> -->

    <!-- 9.3 直接修改元素的样式 -->
    <!-- <div id="div4" style="color: chocolate " >由js修改元素样式</div>
    <input type="button" id="btnReset" value="重置元素样式"> -->
    <!-- DOM（文档对象模型） -->

    <!-- 11 事件模型 -->
    <!-- <button id="test" onclick = "doSomeTing()"></button> -->

    <!-- <input type="button" id="test" value="test"> -->

        
    <!-- 12 事件执行顺序  -->
    <div id="outside" class="outside">
        I am outside. <br><br><br>
        <div id="inner" class="inner">
            I am inner.
        </div>
    </div>

    <script>
        
        /* 注意<script>是放在<body>内部的
        3.Node
        假设我们要判断一个Node 是不是一个元素，通过查表可知元素的nodeType属性值为1，代码可以这么写：
        常量和nodeType值：
        element 1 parentNode可能是Document或Element
        text 3 parentNode是一个Element 没有子节点
        comment 8 parentNode可能是Document或Element 没有子节点
        document 9 nodeValue为null parentNode为null 子节点可能是一个DocumentType或Element
        document_fragment 11 所有节点中唯一一个没有对应标记的类型 nodeValue为null parentNode为null */

        /* var x =  '123';
        if(X.nodeType === 1){
            console.log("X是一个元素");
        } */

        /* 
        4 节点创建型API
        */
        //4.1 createTime通过传入制定的一个 标签名 来创建元素
        // let element = document.createElement(tagName);

        //创建元素并调用appendChild或insertBefore将其添加到HTML树中
/*         let elem = document.createElement("div");
        elem.id = "test";
        elem.style = "color : red";
        elem.innerHTML = "我是新创建的节点";
        document.body.appendChild(elem); */

        //4.2 createTextNode 接受一个参数（文本节点中的文本）
        // var text = document.createTextNode(data);

        //创建文本节点并且通过applendChild将其添加到HTML中
/*         var node = document.createTextNode("我是文本节点");
        document.body.appendChild(node); */

        //4.3 cloneNode 返回调用该方法的节点的一个副本，
        /* node 将要被克隆的节点 dupNode 克隆生成的副本节点 deep（可选）是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身.
        调用接收的deep参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同
        */
        // var dupNode = node.cloneNode(deep);
        
        /* var parent = document.getElementById("parent");
        document.getElementById("btnCopy").onclick = function(){
            var parent2 = parent.cloneNode(true);
            parent2.id = "parent2";
            document.body.appendChild(parent2);
        } */

        //4.4 createDocumentFragment 创建文档片段。将元素附加到文档片段，再将文档片段添加到DOM树中；
        /* 
        在DOM树中，文档片段被其所有的子元素所代替。
        优化性能（文档片段存在于内存而不是dom树，将子元素插入文档片段时不会引起页面回流） */
        // let fragment = document.createDocumentFragment();

        /* 4.4 createDocumentFragment */
        /* (function(){
            var start = Date.now();
            var str = '',li;
            var ul = document.getElementById('ul');
            var fragment = document.createDocumentFragment();
            for (var i = 0 ; i < 10 ; i ++){
                li = document.createElement('li');
                li.textContent = "第" + (i+1) + "个子节点";
                fragment.appendChild(li);
            }
            ul.appendChild(fragment);
        })(); */

        //4.5 节点创建型API总结
        /*         
        节点创建型API主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：
        （1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中
        （2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题
        （3）使用createDocumentFragment来解决添加大量节点时的性能问题 */

        //5 页面修改型API
        // 5.1 appendChild 将指定的节点添加到该方法的节点的子元素的末尾
        // var child = parent.appendChild(child);

        /* child.style = "color : red";
        document.getElementById("btnMove").onclick = function(){
            var child = document.getElementById("child");
            document.getElementById("parent").appendChild(child);
        } */

        //5.2 insertBefore 添加一个节点到一个参照节点之前
        /* parentNode表示新节点被添加后的父节点
        newNode表示要添加的节点
        refNode表示参照节点，新节点会添加在这个节点之前 ;这个参数必须传，不传报错
        如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾
        */
        // parentNode.insertBefore(newNode,refNode);

        /*var parent = document.getElementById("parent");
        var child = document.getElementById("child");
        document.getElementById("btnInsert").onclick = function(){
            var newNode = document.createElement("div");
            newNode.style = "color : red";
            newNode.textContent = "新节点"
            parent.insertBefore(newNode, undefined);
        } */

        //5.3 removeChild 删除指定的 子节点 并返回
        /* deletedChild只想被删除节点的引用，相当于node，被删除的节点仍然在内存中，可以对其进行下一步操作 */
        // var deletedChild = parent.removeChild(node);

        /* 如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除： */
        /* if(node.parentNode){
            node.parentNode.removeChild(node);
        } */

        /* var parent = document.getElementById("parent");
        var child = document.getElementById("child");
        document.getElementById("btnRemoveChild").onclick = function (){
            var deletedChild = parent.removeChild(child);
        } */

        //5.4 replaceChild 使用一个节点替换另一个节点
        /* newChild 会替换掉 oldChild。如果newChild已经存在于DOM树中，则会从DOM树中删除 */
        // parent.replaceChild(newChild,oldChild);

        /* var parent = document.getElementById("parent");
        var child = document.getElementById("child");
        document.getElementById("btnReplaceChild").onclick = function(){
            var newNode = document.createElement("div");
            newNode.textContent = "新节点";
            parent.replaceChild(newNode,child);
        }
 */
        // 6 节点查询型API
        // 6.1 document.getElementById 根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null
        /* 大小写敏感；
        要查找到这个元素那这个元素必须被创建，制定id且被添加到文档中 */
        // var element = document.getElementById(id);

        /* function changeColor(newColor){
            var elem = document.getElementById("para1");
            elem.style.color = newColor;
        } */

        //6.2 document.getElementsByTagName 返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection
        /* 整个文件结构都会被搜索，包括根节点；返回的html集合动态的，会自动更新自己 
        如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率
        如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection 
        name是一个代表元素的名称的字符串；特殊字符 "*" 代表了所有元素*/
        // var elements = document.getElementsByTagName(name);

        /* var divList = document.getElementsByTagName("div");
        document.getElementById("btnShowCount").onclick = function(){
            alert(divList.length);
        }
        document.getElementById("btnAddDiv").onclick = function(){
            var div = document.createElement("div");
            div.textContent = "div" + (divList.length+1);
            document.body.appendChild(div);
        } */

        //6.3 document.getElementsByName 指定的name属性来获取元素，它返回一个即时的NodeList对象
        /* 返回对象是一个即时的NodeList；最好不好设置同样的值给id和name */
        // var elements = document.getElementsByName(name);

        /* function getElements(){
            var x=document.getElementsByName("myInput");
            alert(x.length);
        } */

        // 6.4 document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection
        /* elements是一个实时集合，包含了找到的所有元素
        names是一个字符串，表示要匹配的类名列表；多个类名通过空格分隔
        返回结果是一个即时的HTMLCollection，会随时根据文档结构变化
        IE9以下浏览器不支持
        getElementsByClassName可以在任何元素上调用，不仅仅是document。调用这个方法的元素将作为本次查找的根元素

         */
        // var elements = document.getElementsByClassName(names);//or
        // var elements = rootElement.getElementsByClassName(names);
        //var elements = document.getElementsByClassName("test1 test2");

        //在id为'main'的元素的子节点中，获取所有class为'test'的元素
        // var elements = document.getElementsByClassName("main").getElementsByClassName("test");

        //对任意的HTMLCollection 使用Array.prototype的方法，调用时传递HTMLCollection 作为方法的参数。这里我们将查找到所有class为'test'的div元素
        /* var testElements = document.getElementsByClassName("test");
        var testDivs =Array.prototype.filter.call(testElements,function(testElement){
            return testElement.nodeName === "DIV";
        }); */

        // 6.5 document.querySelector和document.querySelectorAll 
        /* 通过css选择器来查找元素，注意选择器要符合CSS选择器的规则
        querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关
        返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化
         */
        // 6.5.1 document.querySelector document.querySelector
        /* 返回第一个匹配的元素，如果没有匹配的元素，则返回null;这个api使用的是深度优先搜索来获取元素 */
        // var element = document.querySelector(selectors);

        //这个例子体现出querySelector返回第一个匹配元素+使用深度优先的特点
        /* document.getElementById("btnGet").addEventListener("click",function(){
            var element = document.querySelector(".test");
            alert(element.textContent);
        }) */

        //6.5.2 document.querySelectorAll 返回的是所有匹配的元素，而且可以匹配多个选择符
        /* elementList是一个静态的NodeList类型的对象
        selectors是一个由 逗号 连接的包含一个或多个CSS选择器的字符串
        如果selectors参数中包含CSS伪元素,则返回一个空的elementList */
        // var elementList = document.querySelectorAll(selectors);
        // var matches = document.querySelectorAll("div.note,div.alert")

        /* document.getElementById("btnShow").addEventListener("click",function(){
            var elements = document.querySelectorAll("#test,.test");
            for(var i = 0,length = elements.length;i<length;i++){
                alert(elements[i].textContent);
            }
        }) */

        //7.3 兄弟关系型API
        //7.3.1 previousSibling 返回当前节点的前一个兄弟节点,没有则返回null
        /* 包括文本节点
        Gecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.
        因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点 */
        
        //7.3.2 previousElementSibling
        /* previousElementSibling返回当前元素在其父元素的子元素节点中的前一个 元素节点 ,如果该元素已经是第一个元素节点,则返回null,该属性是只读的。
        注意IE9以下浏览器不支持 */

        //7.3.3 nextSibling
        /* Node.nextSibling是一个只读属性，返回其父节点的childNodes列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回null
        包括文本节点
        Gecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.
        因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点（同previousSibling）
         */

        //7.3.4 nextElementSibling
        /* nextElementSibling返回当前元素在其父元素的子元素节点中的后一个 元素节点 ,如果该元素已经是最后一个元素节点,则返回null,该属性是只读的。
        注意IE9以下浏览器不支持 */

        // 7.3.5 parentNode 返回指定节点在DOM树中的父节点。
        // 7.3.6 parentElement 返回指定节点在DOM树中的父元素节点，如果没有父元素或者父元素不是一个元素节点，则返回null。
        // 7.3.7 childNodes 返回指定节点的所有子元素的集合。包括文本节点等
        // 7.3.8 children 返回指定节点的所有子元素的集合。只包含元素节点。
        // 7.3.9 firstChild 返回指定节点的第一个子节点 包括文本节点 
        // 7.3.10 firstElementChild 返回指定节点的第一个子元素节点
        // 7.3.11 lastChild 返回指定节点的最后一个子节点 包括文本节点 
        // 7.3.12 lastElementChild 返回指定节点的最后一个子元素节点




        //8 元素属性型API

        //8.1 setAttribute 设置指定元素上的一个属性值。如果属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值
        // element.setAttribute(name,value);//name是特性名，value时特性值

        /* let div1 = document.getElementById("div1");
        div1.setAttribute("align","center"); */

        //8.2 getAttribute() 返回元素上一个指定的属性值。如果指定的属性不存在，则返回null或""（空字符串）
        // let attribute = element.getAttribute(attributeName);

        /* let div2 = document.getElementById("div2");
        let align = div2.getAttribute("align");
        alert(align); */

        //8.3 removeAttribute() 从指定的元素中删除一个属性
        // element.removeAttribute(attrName)//attrName是一个字符串，将要从元素中删除的属性名

        /* let div = document.getElementById("div3");
        document.getElementById("btnRemoveAttribute").onclick = function(){
            div.removeAttribute("style");
        } */

        //8.4 hasAttribute(attrName)
        // 检测该元素上是否有该属性。返回值为true or false。

       




        //9 元素样式型API

        //9.1 window.getComputedStyle()
        /* 给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算 
        假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle 
        element是要获取的元素 pseudo指定一个伪元素进行匹配
        返回的style是一个CSSStyleDeclaration对象
        通过style可以访问到元素计算后的样式
        */
        // var style = window.getComputedStyle(element[, pseudoElt]);

        // 9.2 getBoundingClientRect 返回元素的大小以及相对于浏览器可视窗口的位置
        /* clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。
        除了IE9以下浏览器，还包含元素的height和width等数据 */
        // var clientRect = element.getBoundingClientRect();

        // 9.3 直接修改元素的样式

        /* var div = document.getElementById("div4");
        document.getElementById("btnReset").onclick = function(){
            div.style.color = "green";
            div.style.setProperty("font-size","20px");
            // div.style.removeProperty("color");
        } */
        

        // 9.4 动态添加样式规则

        //10 DOM事件
        // JS原生事件
        // 11 事件模型

        // 11.1原始事件模型（DOM0级）
        /* 原始事件模型是所有浏览器都支持的事件模型，没有事件流，事件一旦触发会马上执行 */
        //两个方式实现原始事件
        //html中直接指定属性值(见上)
        //js中直接指定属性值
        // document.getElementById("test").onclick = dosomeTing()
        /* 
        优：所有浏览器都兼容。
        劣：
        逻辑与显示没有分离；
        相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的；
        无法通过事件的冒泡、委托等机制处理事情。
        因为这些缺点，虽然原始事件类型兼容所有浏览器，但仍不推荐使用。 
        */

        /* var btn = document.getElementById("test");
        btn.onmousemove = function(e){
            alert("ok");
        };
        btn["onmousemove"] = function(e){
            alert("ok1");
        }//只会输出OK1 */

       /*  //关于this。事件触发时，this指向触发该事件dom对象上
        var btn = document.getElementById("test");
        btn.onmousemove = function (e){
            alert(this.id);
        }//输出test */

        //注销事件
        /* var btn = document.getElementById("test");
        btn.onclick = function(e){
            alert("ok");
        };
        btn.onclick = null;//最后注册的事件要覆盖之前的，最后一次注册事件设置成null，即是注销事件绑定。 */

        // 11.2 DOM2事件模型
        /* W3C
        W3C制定的事件模型中，一次事件的发生包含三个过程：
        1 事件捕获阶段：
        当某个元素触发某个事件，顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。
        在这个过程中，事件相应的监听函数是不会被触发的。
        2 事件目标阶段：当到达目标元素之后，执行目标元素该事件相应的处理函数。
        如果没有绑定监听函数，就不执行。
        3 事件冒泡阶段：从目标元素开始，往顶层元素传播。
        途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。
        所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段。
        不支持事件冒泡的，例如：blur，error，focus，load，mouseenter，mouseleave，resize，unload等。
        阻止冒泡方法，使用stopPropagation（）方法；
         */
        //绑定标准事件监听器
        /* 其中event指定事件名，注意不要加‘on’前缀，与IE下不同；
        第二个参数是指定事件触发时执行的函数；
        第三个参数指定事件是否在捕获或冒泡阶段执行，true 事件句柄在捕获阶段执行，false（默认）事件句柄在冒泡阶段执行。 */
        // element.addEventListener(event, function, useCapture);

        //解除监听器
        // removeEventListener(event, function, useCapture);

        /* 注意：通过removeEventListner()移除时传入的参数与绑定时使用的参数相同。通过addEventListener()添加的匿名函数无法移除，比如： */
        /* var btn = document.getElementById("test");
        btn.addEventListener("click",function(){
            alert(this.id);
        },false);
        btn.removeEventListener("click",function(){//无效
            alert(this.id);
        },false); */

        /* 不能移除的原因：两个方法并不相等，内存地址不同。处理如下： */
        /* var btn = document.getElementById("test");
        var handler = function(){
            alert(this.id);
        };
        btn.addEventListener("click",handler,false);
        btn.removeEventListener("click",handler,false); */

        // 11.3 IE事件模型 ???
        //注册事件
        /* var target = document.getElementById("test");
        target.attachEvent("onclick",function(){
            alert("I am a button");
        }); */

        //移除事件detachEvent()
        //获得event对象，e = window.event（IE中的event对象是个全局属性)。
        //阻止事件冒泡的方法：event的cancelBubble属性为true。
        // e.cancelBubble = true ;
        //阻止默认事件发生：event的returnValue属性为false。
        // e.returnValue = false;

        // 12 事件执行顺序
        /* 点击内层div 先弹出ok1，再弹出ok2
        在目标元素绑定事件，是捕获事件的终点，是冒泡事件的起点，所以这里哪个先注册，就先执行哪个。*/
        /* var btn = document.getElementById("outside");
        //捕获事件
        btn.addEventListener("click",function(e){
            alert("ok1");
        },true);
        //冒泡事件
        btn,addEventListener("click",function(e){
            alert("ok2")
        },false); */

        //注册多个冒泡事件，执行顺序将按照注册的顺序来，先注册先执行。
        //依次弹出ok1，ok2，ok3
        /* var btnInner = document.getElementById("inner");
        btnInner.addEventListener("click",function(e){
            alert("ok1");
        },false);
        btnInner.addEventListener("click",function(e){
            alert("ok2");
        },false);
        btnInner.addEventListener("click",function(e){
            alert("ok3");
        },false); */

        //外层div和内层div同时注册了捕获事件，那么点击内层div时，外层div的事件一定是先触发的
        //先弹出okOutside
        //同理外层div和内层div都是注册的冒泡事件，点击内层div时，一定是内层div事件先执行。(把以下代码的true改为false)
        /* var btnOutside = document.getElementById("outside");
        var btnInner = document.getElementById("inner");
        btnInner.addEventListener("click",function(){
            alert("okInner");
        },true);
        btnOutside = document.addEventListener("click",function(e){
            alert("okOutside");
        },true);
         */


        // 13. 事件委托



        
        




        
    </script>
  


</body>
</html>